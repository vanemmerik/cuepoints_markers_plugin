<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="//www.brightcove.com/favicon.svg">
    <title>Brightcove - Cue Points Player</title>
    <style>
        .container{
            display: flex;
            justify-content: center;
            grid-gap: 20px;
        }

        #video {
            flex-basis: 960px;
            padding-top: 30px;
        }

        #debug{
            font-family: Arial, Helvetica, sans-serif;
            font-size: small;
        }

        #debug code{
            color: #666;
            font-size: 14px;
            background-color: #d5d5d5;
            border-radius: 3px;
            padding: 1px 5px;
        }

        .vjs-cue-control{
            position: absolute;
            height: 100%;
            width: var(--cue-control-width);
        }

        .vjs-cue-marker {
            position: absolute;
            border-radius: 50%;
            background-color: var(--marker-color);
            width: 3px;
            height: 3px;
            transform: scale(2);
            transition: all 300ms ease;
            z-index: 3;
            bottom: 1px;
        }

        .vjs-cue-marker:hover {
            transform: scaleX(2) !important;
            opacity: 100% !important;
        }

        .video-js:hover .vjs-cue-marker {
            border-radius: 0%;
            opacity: 50%;
            height: 100%;
            transform: scaleX(1);
            bottom: unset;
        }

        .vjs-progress-control:hover .vjs-cue-marker {
            height: 170%;
            bottom: -35%;
        }

        .video-js {
            padding: 0 5px;
            bottom: 17px;
            display: none;
        }

        @-webkit-keyframes fade-out {
            from {visibility: visible}
            to { transform: translateY(5px); opacity: 0;}
        }

        @keyframes fade-out {
            from {visibility: visible}
            to { transform: translateY(5px); opacity: 0;}
        }

        .vjs-cue-tip {
            -webkit-animation: fade-out 300ms ease-out;
                    animation: fade-out 300ms ease-out;
            position: absolute;
            pointer-events: none;
            visibility: hidden;
            z-index: 4;
        }

        @-webkit-keyframes fade-in {
            from { transform: translateY(5px); opacity: 0;}
        }

        @keyframes fade-in {
            from { transform: translateY(5px); opacity: 0;}
        }

        .vjs-cue-tip-visible {
            -webkit-animation: fade-in 300ms ease-out;
                    animation: fade-in 300ms ease-out;
            visibility: visible;
        }

        .vjs-cue-data {
            color: #e0e0e0;
            border: 1px solid transparent;
            font-size: 12px;
            border-radius: 0.3em;
            background-color: #000;
            padding: 4px 8px;
            box-shadow: 0px 0px 2px #fdfdfd;
        }

        .vjs-cue-data-left::after {
            position: absolute;
            margin-left: 7px;
            top: 18px;
            font-size: 12px;
            content: "▶";
            color: #000;
            text-shadow: 1px 0px 1px #c6c6c6;
        }

        .vjs-cue-data-right::before {
            position: absolute;
            margin-left: -18px;
            top: 18px;
            font-size: 12px;
            content: "◀";
            color: #000;
            text-shadow: -1px 0px 1px #c6c6c6;
        }

        @-moz-document url-prefix() { 
            .vjs-cue-data-right::before {
                position: absolute;
                margin-left: -19px;
                top: 17px;
            }
        }

        /* For Tablet View */
        @media screen and (min-device-width: 768px)
        and (max-device-width: 1024px) {
            .vjs-cue-marker {
                display: none;
            }
            .vjs-cue-tip {
                display: none;
            }
            .vjs-cue-data {
                display: none;
            }
        }
        
        /* For Mobile Portrait View */
        @media screen and (max-device-width: 480px)
        and (orientation: portrait) {
            .vjs-cue-marker {
                display: none;
            }
            .vjs-cue-tip {
                display: none;
            }
            .vjs-cue-data {
                display: none;
            }
        }
        
        /* For Mobile Landscape View */
        @media screen and (max-device-width: 640px)
        and (orientation: landscape) {
            .vjs-cue-marker {
                display: none;
            }
            .vjs-cue-tip {
                display: none;
            }
            .vjs-cue-data {
                display: none;
            }
        }
        
        /* For Mobile Phones Portrait or Landscape View */
        @media screen and (max-device-width: 640px) {
            .vjs-cue-marker {
                display: none;
            }
            .vjs-cue-tip {
                display: none;
            }
            .vjs-cue-data {
                display: none;
            }
        }
</style>
</head>
<body>

<div class="container">
    <div id="output">
        <p id="debug">Mediainfo <code>cuePoints</code> data</p>
        <code style="color: green;" id="insertionPoint_MI"></code>
        <p id="debug">Activecues <code>cues</code> data</p>
        <code style="color:brown;" id="insertionPoint_C"></code>
        <p id="debug">Activecues <code>activeCue</code> data</p>
        <code id="insertionPoint_AC"></code>
    </div>
    <div style="max-width: 960px;" id="video">
        <style>
            video-js.video-js.vjs-fluid:not(.vjs-audio-only-mode) {
                padding-top: 56.25%;
                }
        </style>
        <video-js
            id="myPlayer" 
            data-account="5380177774001" 
            data-player="default" 
            data-embed="default" 
            controls=""
            playsinline
            data-video-id="1760202275610894432" 
            data-playlist-id=""
            data-application-id="" 
            class="vjs-fluid">
        </video-js>
    </div>
</div>
<script src="//players.brightcove.net/5380177774001/default_default/index.min.js"></script>
<script type="text/javascript">
    var options = {"cue_marker_color": "#03fcf4"};
  </script>
<script>
    videojs.getPlayer('myPlayer').ready(function() {
      var myPlayer = this;
      myPlayer.cuePointMarkersPlugin(options);
    });
    videojs.registerPlugin('cuePointMarkersPlugin', function(options) {
        var player = this;
        player.on('loadedmetadata', function() {
            let cuePointsArr = new Array(),
                filteredCueArr = new Array(),
                purgedCueArr = new Array(),
                tt = player.textTracks()[0], // ********* Remove ********* for debugging purposes in standalone HTML example
                // Define the video duration as a variable
                videoDuration = player.mediainfo.duration,
                // Get Video Cloud metadata long description field
                longDesc = player.mediainfo.longDescription,
                // Define video ID for playlist player management
                videoId = player.mediainfo.id;
            // Add existing cue point metadata to the cue points array
            for (let i = 0; i < player.mediainfo.cuePoints.length; i++){
                cuePointsArr.push(player.mediainfo.cuePoints[i]);
            }
            // Check for chapters in the longDescription metadata field, sort and merge
            xtractMatch(longDesc, cuePointsArr, videoDuration, videoId);
            // Add to filtered array based on original
            filteredCueArr = cuePointsArr.filter(cue => (cue.type === 'CODE') || (cue.type === 'TEXT'));
            // Remove duplicates based on time and replace
            purgedCueArr = dedupeArr(filteredCueArr);
            // Assign endTime to cue points in sorted array
            assignCueEndTime(purgedCueArr,videoDuration);
            // Take purged cue point information and add cue markers to player progress bar
            addCueEl(purgedCueArr, videoDuration, options);
            displayMetaInfo(tt, purgedCueArr); // ********* Remove ********* for debugging purposes in standalone HTML example
            // If playlist player/playlist is present - clear UI for new playlist item
            if (player.playlistUi !== undefined) player.on('playlistitem', function(){rmCueEl()})
        })
    });
    // ********* Remove ********* for debugging purposes in standalone HTML example
    const displayMetaInfo = (tt, arr) => {
        tt.oncuechange = function () {
            if (tt.activeCues[0] !== undefined) {
            var dynamicHTML_AC = "id: " + tt.activeCues[0].originalCuePoint.id + ", ";
            dynamicHTML_AC += "type: " + tt.activeCues[0].originalCuePoint.type + ", ";
            dynamicHTML_AC += "name: " + tt.activeCues[0].originalCuePoint.name + ", ";
            dynamicHTML_AC += "startTime: " + tt.activeCues[0].startTime + ",  ";
            dynamicHTML_AC += "endTime: " + tt.activeCues[0].endTime;
            document.getElementById("insertionPoint_AC").innerHTML += dynamicHTML_AC + "<br/>";
            }
        }
        let dynamicHTML_C = "",
            dynamicHTML_MI = "";
        for (i = 0; i < tt.cues.length; i++ ) {
            dynamicHTML_C += "id: " + tt.cues[i].originalCuePoint.id + ", ";
            dynamicHTML_C += "type: " + tt.cues[i].originalCuePoint.type + ", ";
            dynamicHTML_C += "name: " + tt.cues[i].originalCuePoint.name + ", ";
            dynamicHTML_C += "startTime: " + tt.cues[i].startTime + ", ";
            dynamicHTML_C += "endTime: " + tt.cues[i].endTime + "<br/>";
        }
        document.querySelector("#insertionPoint_C").innerHTML = dynamicHTML_C;
        for (i = 0; i < arr.length; i++ ) {
            dynamicHTML_MI += "id: " + arr[i].id + ", ";
            dynamicHTML_MI += "type: " + arr[i].type + ", ";
            dynamicHTML_MI += "name: " + arr[i].name + ", ";
            dynamicHTML_MI += "startTime: " + arr[i].startTime + ", ";
            dynamicHTML_MI += "endTime: " + arr[i].endTime + "<br/>";
        }
        document.querySelector("#insertionPoint_MI").innerHTML = dynamicHTML_MI;
    }

    const xtractMatch = (string, arr, videoDuration, videoId) => {
            // Match time formats M:SS, MM:SS, HH:MM:SS, H:MM:SS
        let tRex = new RegExp(/(^(?:[01]\d|2[0-3]|[0-59]):[0-5]\d:[0-5]\d)|(^(?:[0-5]\d|2[123]|[0-59]):[0-5]\d)/gm),
            // Match whole line that begins with 00: Lines with time format not at the beginning are ignored
            dRex = new RegExp(/^.*?(^[0-5][0-9]:|^[0-59]:).*$/gm),
            chaptrTime = string.match(tRex),
            chaptrName = string.match(dRex);
            // No found chapters - sort the array as it is and skip adding any further cue information
        if (chaptrTime === null) return(arrSort(arr));
        for (let i = 0; i < chaptrTime.length; i++) {
            let time = chaptrTime[i].split(':'),
                description = chaptrName[i].slice(chaptrTime[i].length),
                seconds,
                // Add ranomised 13 digit ID
                idNum = Math.floor(Math.random() * 9000000000000) + 1000000000000;
            // Strip hyphens and other intersting chars from string and trim whitespace    
            description = stringTidy(description);
            // push into array objects
            timeConversion(arr, time, idNum, seconds, description, videoDuration, videoId);
        }
        // Sort array based on time
        arrSort(arr);
    }

    // Array sort - order array based on time from lowest to highest
    const arrSort = (arr) => {
        arr.sort((a, b) => {
            return a.time - b.time;
        });
    }

    // Removal of hyphens, pluses but allows inverted commas etc
    const stringTidy = (str) => {
        str = str.replace(/([.,\/;:*{}=\-_~()<>{}+])/g, '');
        // Remove whitespace form either end of the string
        str = str.trim();
        return(str);
    }

    const timeConversion = (arr, time, idNum, seconds, description, duration, videoId) => {
        // Check for words in description if none set fields to blank
        if (description.match(/\b[^\d\W]+\b/g) === null) description = '';
        if (time.length === 2){
            // Convert MM:SS to seconds
            seconds = (Number.parseFloat(time[0]) * 60 + Number.parseFloat(time[1]));
            // If chapter is longer than the video skip
            if (seconds > duration) return;
            arr.push({
                id: `${idNum}`,
                name: description,
                type: 'TEXT',
                time: seconds,
                metadata: description,
                startTime: seconds,
                endTime: '',
                video_id: videoId
            });
        }
        if (time.length === 3){
            // Convert HH:MM:SS to seconds
            seconds = (Number.parseFloat(time[0]) * 3600 + Number.parseFloat(time[1]) * 60 + Number.parseFloat(time[2]));
            // If chapter is longer than the video skip
            if (seconds > duration) return;
            arr.push({
                id: `${idNum}`,
                name: description,
                type: 'TEXT',
                time: seconds,
                metadata: description,
                startTime: seconds,
                endTime: '',
                video_id: videoId
            });
        }
    }

    // Filter array through map - remove duplicates
    const dedupeArr = (arr) => { 
        let mapObj = new Map()
        arr.forEach(v => {
            let prevValue = mapObj.get(v.time)
            if(!prevValue){
                mapObj.set(v.time, v)   
            }
        })
        return [...mapObj.values()];
    }

    // Hacky method to reassign endTime cue data in array after arrSort
    const assignCueEndTime = (arr, duration) => {
        // Order the array on time again - for loop uses time from preceding array object 
        arrSort(arr);
        let v = 1;
        for (let i = 0; i < arr.length; i++) {
            if (v <= arr.length - 1)arr[i].endTime = arr[v].time;
            // If last object in array set end time to video duration
            if (v === arr.length) arr[i].endTime = duration;
            v++;
        }
    }

    // Build cue point markers and add them to the player progress bar
    const addCueEl = (arr, videoDuration, options) => {
        let playerWidth = document.querySelector('video-js').offsetWidth,
            controlBar = document.querySelector('.vjs-progress-control'),
            progresBar = document.querySelector('.vjs-progress-holder'),
            cueControl = document.createElement('div'),
            cueTip = document.createElement('div');
        cueTip.className = 'vjs-cue-tip';
        cueControl.className = 'vjs-cue-control';
        cueControl.style.setProperty('--cue-control-width', playerWidth + 'px');
        controlBar.prepend(cueControl);
        progresBar.appendChild(cueTip);
        // Loop through array and add elements
        for (let i = 0; i < arr.length; i++) {
            let el = document.createElement('div');
            el.className = 'vjs-cue-marker';
            el.id = 'marker' + i;
            el.style.setProperty('--marker-color', options.cue_marker_color);
            // On mouse over event - add mouse event listener to cue marker elements
            el.addEventListener("mouseover", (e) => {
                setCueInfo(e, arr);
            });
            let time = arr[i].time;
            // Based on proportion of width in px using time 
            el.style.left = `${Math.round(time / videoDuration * playerWidth)}px`;
            cueControl.append(el);
        }
        // Create the inner placeholder for the cue point data on the tooltips
        createCueInfoEl();
    }

    // Remove created elements if playlist is present and new video has loaded
    const rmCueEl = () => {
        let cueControl = document.querySelector('.vjs-cue-control'),
            cueTip = document.querySelector('.vjs-cue-tip');
        if (cueTip !== null) cueTip.remove();
        if (cueControl !== null) cueControl.remove();
    }

    // Create and introduce to DOM the information tool data
    const createCueInfoEl = () => {
        let cueTipData = document.createElement('p'),
            cueTip = document.querySelector('.vjs-cue-tip');
        cueTipData.className = 'vjs-cue-data';
        cueTip.appendChild(cueTipData);
    }

    // Control mouse interaction with the cue markers - Initiated on hover state
    const setCueInfo = (e, arr) => {
        let i = e.target.id.slice(6),
            cueHolder = document.querySelector('.vjs-cue-control').offsetWidth,
            cueMarker = document.querySelectorAll('.vjs-cue-marker')[i],
            cueTip = document.querySelector('.vjs-cue-tip'),
            cueTipData = document.querySelector('.vjs-cue-data');
        cueTip.classList.add('vjs-cue-tip-visible');
        cueTipData.innerHTML = `${arr[i].name}`;
        cueTip.style.display = null;
        // Display cue tool tip on left or right of marker on hover based on position
        if (cueMarker.offsetLeft > cueHolder / 2){
            cueTipData.classList.remove('vjs-cue-data-right');
            cueTipData.classList.add('vjs-cue-data-left');
            cueTip.style.left = null;
            cueTip.style.right = cueHolder - cueMarker.offsetLeft +20 + 'px';
        } else {
            cueTipData.classList.remove('vjs-cue-data-left');
            cueTipData.classList.add('vjs-cue-data-right');
            cueTip.style.right = null;
            cueTip.style.left = cueMarker.offsetLeft +20 + 'px';
        }
        if (arr[i].name === '') cueTip.style.display = 'none';
        // Mouse move event - follow the mouse pointer on Y axis only
        cueMarker.addEventListener('mousemove', (e) => {
            cueTip.style.top = e.offsetY - 27 + 'px';
        });
        // On mouse out event - remove inline styles and classes
        cueMarker.addEventListener('mouseout', () => {
            cueTip.classList.remove('vjs-cue-tip-visible');
        });
}
</script>
</body>
</html>